<?php
/**
 * @file
 * Mica Import  file
 */

/**
 * Implements hook_permission().
 */
function mica_import_permission() {
  $perms = array();
  foreach (node_permissions_get_configured_types() as $type) {
    $info = node_type_get_type($type);
    $perms += array(
      "import $type content" => array(
        'title' => t('%type_name: Import content', array('%type_name' => $info->name)),
      )
    );
  }
  return $perms;
}

/**
 * Implements hook_menu().
 */

function mica_import_menu() {

  $items = array();
  $items['import-xml'] = array(
    'title' => 'Import nodes from XML',
    //@TODO check if user have permission to import at least one node type
    'access callback' => 'mica_import_can_import_node',
    //  'access arguments' => array(0),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mica_import_upload_form'),
  );
  return $items;
}

function mica_import_can_import_node() {
  //@TODO check if user have permission to import at least one node type
  return TRUE;
}

function mica_import_upload_form() {
  $form['file'] = array(
    '#type' => 'file',
    '#title' => t('XML to Upload'),
    '#description' => t('Upload a Zip file to import , allowed extensions:zip'),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
  );
  return $form;
}

function mica_import_upload_form_submit($form, &$form_state) {
  $file = $form_state['storage']['file'];
  // We are done with the file, remove it from storage.
  unset($form_state['storage']['file']);
  // Make the storage of the file permanent
  $file->status = FILE_STATUS_PERMANENT;
  // Save file status.
  file_save($file);
  // Set a response to the user.
  drupal_set_message(t('The file ZIP has been uploaded, filename: @filename.', array('@filename' => $file->filename)));

}

function mica_import_upload_form_validate($form, &$form_state) {
  global $user;
  $file = file_save_upload('file', array(
    'file_validate_extensions' => array('zip'), // Validate extensions.
  ));

  // If the file passed validation:
  if ($file) {
    $directory = 'public://' . $user->name . '/export';
    if (!is_dir($directory)) {
      drupal_mkdir($directory, NULL, TRUE, NULL);
    }

    // Move the file, into the Drupal file system
    if ($file = file_move($file, $directory, FILE_EXISTS_RENAME)) {
      // Save the file for use in the submit handler.
      $form_state['storage']['file'] = $file;
      if ($path_file = _mica_import_unzip_file($file)) {
        if (is_dir($path_file)) {

          _mica_import_batch_import($path_file);

        }
      }

    }
    else {
      form_set_error('file', t('Failed to write the uploaded file to the site\'s file folder.'));
    }
  }
  else {
    form_set_error('file', t('No file was uploaded.'));
  }
}

/*
 * Unzip file Method
 * @param $file Object send by form upload
 *
 * */
function _mica_import_unzip_file($file) {
  if ($wrapper = file_stream_wrapper_get_instance_by_uri($file->uri)) {
    $file_path = $wrapper->realpath();
    $zip = new ZipArchive();
    $res = $zip->open($file_path);
    if ($res === TRUE) {
      $to_path_file = file_stream_wrapper_get_instance_by_uri('temporary://')->realpath();
      $zip->extractTo($to_path_file);
    }
    else {
      switch ($res) {
        case $res == ZipArchive::ER_EXISTS:
          $error_zip = 'File already exists';
          break;
        case $res == ZipArchive::ER_INCONS:
          $error_zip = 'Zip archive inconsistent';
          break;
        case $res == ZipArchive::ER_INVAL:
          $error_zip = 'Invalid argument';
          break;
        case $res == ZipArchive::ER_MEMORY:
          $error_zip = 'Malloc failure';
          break;
        case $res == ZipArchive::ER_NOENT:
          $error_zip = 'No such file';
          break;
        case $res == ZipArchive::ER_NOZIP:
          $error_zip = 'Not a zip archive';
          break;
        case $res == ZipArchive::ER_OPEN:
          $error_zip = 'Can\'t open file, error file path';
          break;
        case $res == ZipArchive::ER_READ:
          $error_zip = 'Read error';
          break;
        case $res == ZipArchive::ER_SEEK:
          $error_zip = 'Seek error';
          break;
        default:
          $error_zip = 'Unknown error';

      }

      form_set_error('file', t("Failed to Unzip file, system  error : $error_zip"));
      return FALSE;
    }
    $zip->close();
    return $to_path_file . DIRECTORY_SEPARATOR . substr($file->filename, 0, -4);
  }
  return FALSE;
}

function _mica_import_batch_import($path) {

  $operations = array();
  $scanned_directory = array_diff(scandir($path), array('..', '.'));
  foreach ($scanned_directory as $file) {
    $file_xml = $path . DIRECTORY_SEPARATOR . $file;
    if (is_file($file_xml)) {
      $operations[] = array('_mica_import_import_node', array($file_xml));
    }

  }

  // prepare batch steps
  batch_set(array(
    'operations' => $operations,
    'finished' => 'mica_import_batch_finished',
  ));

  batch_process('/');

}

function _mica_import_import_node($file_xml, &$context) {
  $errors_message =array();
  $context['message'] = t('Extract information from %file_xml', array('file_xml' => $file_xml));
  $dom = new DOMDocument();
  $dom->load($file_xml);
  $current_document = $dom->documentElement;
  $type_node = $current_document->nodeName;
  $uuid = $current_document->getAttribute("uuid");
  $type_node = str_replace('-', '_', $type_node);
  // Node exist?  Update or create node
  $wrapper = _mica_import_find_or_create_node($uuid, $type_node);
if($wrapper === false){
  $context['message'] = t('Action for this node : %node aborted', array('%node'=>$type_node));

}
  else{
  //Set Nodes from XML,s files
  module_invoke_all('mica_import_set_node_properties', $dom, $wrapper);

  //Save created node
  $wrapper->save();
  }
  $context['message'] = $errors_message;
}

function mica_import_batch_finished(&$context) {
  drupal_set_message( $context['message']);
}

function _mica_import_find_or_create_node($uuid, $type) {
  global $user;

  if ($nodes = entity_uuid_load('node', array($uuid), array())) {

    $node = current($nodes);
    $wrapper = entity_metadata_wrapper('node', $node->nid);
    if(
    user_access('import '.$type.' content')  &&
    (user_access('edit own '.$type.' content')  ||
    user_access('edit any '.$type.' content'))
    )
    {return $wrapper;}
    else {dpm(t('No permission to update or edit : '.$node->type.' content'));
    return false;
    }
  }

  watchdog('mica', 'Create new node with UUID %uuid Call by %type ', array(
    '%uuid' => $uuid,
    '%type' => $type
  ), WATCHDOG_DEBUG);

  $infos = array(
    'type' => $type,
    'uid' => $user->uid,
    'status' => NODE_NOT_PUBLISHED,
    'uuid' => $uuid
  );
  if(
    user_access('import '.$type.' content')  &&
    user_access('create '.$type.' content')
  )
  {
  // Creates a wrapper object without inserting it to the DB
  $wrapper = entity_property_values_create_entity('node', $infos);
  return $wrapper;
  }
  else{
    dpm(t('No permission to create or edit : '.$type.' content'));
    return false;
  }
}

/**
 * Copy attachment files of each node
 */
function mica_import_copy_attachment_file($documents, $type, $tmp_folder_name) {
  $path = "temporary://$tmp_folder_name/$type-documents";
  if (!is_dir($path)) {
    drupal_mkdir($path);
    foreach ($documents as $document) {
      file_unmanaged_copy($document['uri'], $path, FILE_EXISTS_REPLACE);
    }
  }
}

function _mica_import_find_or_create_file($file_uuid,$type,$value_document ){
  dvm($type);
  dvm($value_document);

  if ($file_id = entity_get_id_by_uuid('file', array($file_uuid))) {
    foreach ($file_id as $id) {
      if ($file = file_load($id)) {
      //  file_usage_delete($file, 'node',$type );
        //file_delete($file,true);
        dpm($file);
      }


    }
  }

return $id;
}


